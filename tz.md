Задание:
Спроектировать и реализовать изоморфный логгер.

Функциональные требования:
Логгер должен уметь поддерживать несколько каналов, представляющие собой некий источник сообщений определенной тематики/относящихся к какому-то конкретному сервису или подсистеме. Например - mail, exchange, acquiring. Каналы задаются в конфигурации логгера при его инициализации, после чего им можно начинать пользоваться.

Для каждого канала в конфигурации определяется индивидуальный уровень вывода ошибок (error, warning, notice, info, debug). Если для канала установлен уровень warning, но в канал через логгер отправляется сообщение уровня info - сообщение игнорируется и не передается в транспорты (см. ниже).

Для каждого канала при начальной конфигурации должно быть возможно назначить один или несколько транспортов (куда будет записываться/выводиться лог). Самый очевидный - в консоль браузера, но также, например, возможно, что некоторые отладочные данные с фронта необходимо отправить на бэк (или удаленный сервер), чтобы сохранить и проанализировать. Требуется реализовать два указанных транспорта и возможность простого написания собственных произвольных транспортов.

Транспорта в консоль использует формат вывода вида: [2021-01-13 13:03:32] soap_server.INFO: <само_сообщение> - [время] канал.УРОВЕНЬ_СООБЩЕНИЯ <само_сообщение>. Транспорт на сервер передает данные как JSON со списком сообщений через протокол JSON-RPC 2.0. Для вывода warning и error используем console.warn() и console.error().
Для каждого транспорта также возможно установить свой собственный уровень. Если для канала установлен уровень info и в канал отправляется сообщение уровня info, то оно поступит на обработку только в транспорты с уровнем info или ниже.

Логгер должен поддерживать цвета в сообщениях в консоли (см. документацию про объект console в MDN) и предоставлять fluent API для построения подобных сообщений - например, в сообщении об ошибке сперва может идти код ошибки, затем ее текст, и потом два неких отладочных числовых значения, все разного цвета. Для различных типов сообщений (error, warning, notice) также используем различные цвета по умолчанию, оставляя возможность переопределить их в транспорте. Транспорт на удаленный сервер данные о цветах игнорирует.

Логгер должен поддерживать группировку сообщений через console.group(). Но при отправке таких сообщений на бэк группы должны интерпретироваться как отдельное сообщение без вложенности (т.е. “Поехали (группа)”, “Хьюстон, у нас проблемы”, “Приехали (конец группы)” - три сообщения один за другим). Уровнем группы считаем info.

Примерная схема работы

// Создаем инстанс логгера на основе конфигурации 
const logger = Logger.build({
    mail: {
        transports: [{
            // консольный транспорт
        }, {
            // http транспорт
        }]
    } 
});
// Используем логгер - отправляем сообщение в канал mail.
// Логгер самостоятельно перенаправляет его в указанные в конфигурации каналы (а те - в определенные для них транспорты) для дальнейшей обработки
logger.mail.warning(“Все пропало, шеф!”);

Или любой другой альтернативный, но не менее удобный синтаксис.

Технические требования
Пакет не должен использовать другим зависимости. Для запросов используем fetch.
Всё должно быть максимально красиво построено на ES6-классах. Использовать POJO для хранения данных запрещено.
Классы должны быть документированы через jsdoc. К репозиторию должно быть приложено подробное README.
Минимальная реализация - в виде простого набора классов. Опциональная - в виде npm-пакета.
Использование Typescript будет плюсом.



